extending_currentproductid:
  question: |
    What is the proper way to pass a JavaScript variable into your app via the template?
  explanation: |
    Remember to always escape your data so that you don't bump into JavaScript errors
    if your variable contains things like quotes!
  features:
    multiple_choice:
      choices:
        a: |
          ```twig
          <script>
             var mySharedVariable = '{{ mySharedValue }}';
          </script>
          ```
        b: |
          ```twig
          <script>
             window.mySharedVariable = '{{ mySharedValue|e('js') }}';
          </script>
          ```
        c: |
          ```twig
          <script>
             window.mySharedVariable = '{{ mySharedValue }}';
          </script>
          ```
        d: |
          ```twig
          <script>
              mySharedVariable = '{{ mySharedValue|e('js') }}';
          </script>
          ```
      correct: b

extending_dynamic_component:
  question: |
    Say we have 2 components and we need to dynamically render them based on
    a condition. One of them will be rendered if we have information about a
    pizza's topping, while the other will be rendered if such information is
    null.

    Here's our component with the two sub components rendered using a `v-if`
    directive:

    ```vue
    <template>
        <pizza-list v-if="pizzaTopping === null" />

        <pizza-description v-if="pizzaTopping !== null" />
    </template>

    <script>
    import PizzaList from '@/components/pizza-list';
    import PizzaDescription from '@/components/pizza-description';
    import { getPizzaToppingInfo } from '@/helpers/get-pizza-topping-info';

    export default {
        name: 'PizzaPage',
        data() {
            return {
                pizzaTopping: getPizzaToppingInfo(),
            };
        },
        computed: {
            dynamicComponent() {
                return this.pizzaTopping === null ? PizzaList : PizzaDescription;
            }
        },
    };
    </script>
    ```

    How can we use the `dynamicComponent` computed property to
    render the correct component based on `this.pizzaTopping`?
  explanation: |
    The dynamic component has the the special `is` prop that, when used *dynamically*
    (like `:is`), can render one component or another based on its value!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <component :is="dynamicComponent" />
          </template>
          ```
        b: |
          ```vue
          <template>
              <component is="dynamicComponent" />
          </template>
          ```
        c: |
          ```vue
          <template>
              <component :pizza-list="dynamicComponent" />
          </template>
          ```
        d: |
          ```vue
          <template>
              <component
                  :pizza-list="!dynamicComponent"
                  :pizza-description="dynamicComponent"
              />
          </template>
          ```
      correct: a

extending_ajax_delay_rendering:
  question: |
    Which of the following will result in an
    Ajax call that's executed *as soon as possible* and then set the
    returned value onto a piece of data?
  explanation: |
    The first place in our component where we can make
    Ajax calls is our `created` function!

    Notice there's nothing technically wrong with making an Ajax call outside
    of the component definition itself, but it will make things...
    well... complicated! In theory, you risk getting a value even
    *before* the component has been instantiated. Instead, use `created`:
    that's the whole point of that hook function!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          const myStoredData;
          myAjaxCallFunction().then((response) => {
              myStoredData = response.data['hydra:member'];
          });

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData,
                  };
              },
          };
          ```
        b: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData: null,
                  };
              },
              async beforeMount() {
                  this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
              },
          };
          ```
        c: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData: null,
                  };
              },
              async created() {
                  this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
              },
          };
          ```
        d: |
          ```javascript
            import { myAjaxCallFunction } from '@/services/my-service';

            export default {
                name: 'MyComponent',
                data() {
                    return {
                        myStoredData: null,
                    };
                },
                async mounted() {
                    this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
                },
            };
            ```
      correct: c

extending_product_template:
  question: |
    Imagine that our product template has a section that is wrapped
    in a `v-if` directive, only to be shown if `product !== null`, as shown
    in this lesson.

    ```vue
    <template>
        <div :class="$style.component">
            <loading v-show="loading" />

            <h1 v-if="product !== null">{{ product.title }}</h1>
        </div>
    </template>

    <script>
    export default {
        name: 'ProductComponent',
        data() {
            return {
                loading: true,
                product: null,
            };
        },
        // Some more computed, life cycle functions and methods here
    };
    </script>
    ```

    What would happen if we removed this `v-if` and let the page
    render either way?
  explanation: |
    While our app *would* work once `product` loads,
    we will be getting errors in the console because our `product` object is
    `null` when the component first instantiates.

    The errors come from this brief moment when our application tries to render
    but its data still hasn't loaded. Once it loads, though, reactivity makes it
    so that the component re-renders: this time with all the information it needs.
  features:
    multiple_choice:
      choices:
        a: |
          We would have render errors in our App, preventing the component from
          rendering
        b: |
          Our App could crash, making the browser unresponsive
        c: |
          The App would work just the same, rendering once our data has loaded
        d: |
          We would have errors in the console, for example, indicating that
          `product.title` is `undefined`, but it *would* still render once the
          `product` data became available.
      correct: d

extending_add_to_cart:
  question: |
    Imagine we have a component whose sole purpose is to render an input element:

    ```vue
    <template>
        <input type="text" v-model="myValue" />
    </template>

    <script>
    export default {
        name: 'InputComponent',
        data() {
            return {
                myValue: '',
            };
        },
    };
    </script>
    ```

    Which of the following `:disabled` attributes would result in an input element
    being *disabled*?
  explanation: |
    According to Vue documentation:

    ```
    If [ the value of a `disabled` attribute ] has the value of null, undefined,
    or false, the `disabled` attribute will not even be included in the rendered
    <button> element.
    ```

    This implies that any string value will evaluate to `true`!

    > Note that `someUndefinedVariable` is undefined since I haven't defined it in the object's
    > `data` or `props`. This *will* throw a warning in the console, but the return value
    > is still `undefined`.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <input :disabled="'0'" />
          ```
        b: |
          ```vue
          <input :disabled="false" />
          ```
        c: |
          ```vue
          <input :disabled="null" />
          ```
        d: |
          ```vue
          <input :disabled="someUndefinedVariable" />
          ```
      correct: a

extending_cart_loading_quantity:
  question: |
    Imagine we wrote a component that needs to take a number and send its value plus 2
    to my database (a VERY useful scenario, I know!):

    ```vue
    <template>
        <input
            type="number"
            v-model="theNumber"
            min="1"
        />

        <button @click="sendNumber">
            Send!
        </button>
    </template>

    <script>
    import { saveNumber } from '@/services/save-number';

    export default {
        name: 'MyComponent',
        data() {
            return {
                theNumber: 0,
            };
        },
        methods: {
            sendNumber() {
                saveNumber(this.theNumber + 2);
            },
        },
    };
    </script>
    ```

    But, oh! I've just discovered that there is a massive bug in this code!
    When I entered the number `1`, it saved the number `12` instead of `3`!
    What is the best way to fix this?
  explanation: |
    The *best* way to fix this is by using the directive attribute
    `number`! This will take care of all the number conversions for us
    under the hood. We'll never have to worry about it!

    > Option `a` will still work, but `v-model.number` does the same work for us
    > out of the box! Option `b` is a syntax error, and `d` might just hang your browser!!
  features:
    multiple_choice:
      choices:
        a: |
          methods: {
              sendNumber() {
                  saveNumber(parseInt(this.theNumber) + 2);
              },
          },
        b: |
          ```vue
          <input
              type="number"
              v-model.parseInt="theNumber"
              min="1"
          />
          ```
        c: |
          ```vue
          <input
              type="number"
              v-model.number="theNumber"
              min="1"
          />
          ```
        d: |
          ```vue
          <input
              type="number"
              v-model="theNumber"
              @input="$event.target.value=parseInt(theNumber)"
              min="1"
          />
          ```
      correct: c


extending_webpack_entry:
  question: |
    Suppose we have a Symfony project that uses Webpack Encore. We've just finished
    building a new Vue component, but we only want to render it on a specific page.
    And so, we've decided to create a new Webpack entry.

    Which of the following options is not something that we need to do to accomplish this?
  explanation: |
    The 3 steps to creating a new Webpack entry that renders a Vue component are:
    - The .vue file with the component itself
    - A Controller that renders a Twig template, which includes a JavaScript file that
      renders the app inside this template
    - An entry in `webpack.config.js` to build our application.

    And while passing variables into our Vue component through the template is *nice*,
    it's not always needed!
  features:
    multiple_choice:
      choices:
        a: |
          A new `.vue` file to hold the new, main component
        b: |
          A `javascripts` block in the Twig template that contains different configurations
          and values to be used by our Vue App
        c: |
          A Controller, a Twig template and JavaScript file that will be loaded by the browser
          to instantiate the main component.
        d: |
          An `addEntry` call in `webpack.config.js` to tell webpack that it should build the file.
          a new entry.
      correct: b

extending_webpack_entry_2:
  question: |
    Which of these JavaScript file examples will succeed in rendering a Vue component
    in `Vue 2` inside an element with id `app`?
  explanation: |
    This bit of JavaScript code can be quite tricky to remember (and
    it does change slightly in Vue 3)!

    Thankfully we have the Vue documentation site to refresh our memory if any of these
    nuances get lost in forgotten-land!

    > In Vue 3, the code changes to:
    >
    > ```vue
    > import { createApp } from 'vue';
    > import App from '@/pages/my-page.vue';
    >
    > createApp(App).mount('#app');
    > ```
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          });
          ```
        b: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$mount('#app');
          ```
        c: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$render('#app');
          ```
        d: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          }).$mount('#app');
          ```
      correct: d

extending_mixin_basics:
  question: |
    Which of the following is *not* true about mixins?
  explanation: |
    Mixins are a *great* way to share logical functionality between
    components! They do not, however, have the ability to extend markup or
    styles. For that, just use regular components!
  features:
    multiple_choice:
      choices:
        a: |
          Mixins can help you share information between components, such as
          data attributes and even props!
        b: |
          Mixins can be useful for sharing methods and computed properties
          between components. Its properties and methods will be automatically
          available to other methods and even the template of the component
          you share it with!
        c: |
          Mixins are a great way to extend the template or styles in a component.
          The mixin template will be added to the component's template at the bottom, and styles
          will be automatically applied to any elements you provide styles for!
        d: |
          Mixins can help you with lifecycle behavior. By adding lifecycle functions
          to a mixin, those will be executed before any of your own component's
          lifecycle functions without replacing them! Sweet!
      correct: c

extending_more_mixin:
  question: |
    Take a look at these two components. Then choose which option below correctly shows
    a mixin that will allow them to remove their duplicated logic.

    ```vue
    <template>
        <h1>{{ pizzaName }}</h1>
        <p>{{ pizza.description }}</p>
        <ul>
            <li
                v-for="ingredient in pizza.ingredientes"
                :key="ingredient['@id']"
            >
                {{ ingredient.name }}
            </li>
        </ul>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaName() {
                return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```

    ```vue
    <template>
        <table v-if="pizza !== null">
            <tr>
                <td>{{ pizzaDescription }}</td>
                <td>{{ pizza.price }} </td>
            </tr>
        </table>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaDescription() {
                return this.pizza.name +  ' ' + pizza.description;
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```
  explanation: |
    The only data that is really shared between the components is the `pizza` data
    object and the `created` function. Everything else is unique to each component
    and so extracting it to a mixin does *not* make the most sense.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              }
          };
          ```
        b: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
        c: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
              },
          };
          ```
        d: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
      correct: a

extending_more_mixin_2:
  question: |
    Say I have this very simple counter component:

    ```vue
    <template>
        <div v-text="count" />
    </template>

    <script>
    export default {
        name: 'CounterComponent',
        data() {
            return {
                count: 0,
            };
        },
    };
    </script>
    ```

    Why is it important that data is a *function* that returns an object?
    Why can't data be set directly to the `{ count: 0 }` object?
  explanation: |
    As mentioned in Vue documentation, the reason why Vue needs
    data to be a function os so that each instance of the component can
    maintain a different copy of this data.

    This doesn't happen with `props` however, where we define each prop inside the
    `props` object, but we don't make it a function! The reason `props` doesn't
    need to be inside a function is because they don't really hold data. Its
    data is either passed down by other components on initialization, or defined
    by our `default` keyword.
  features:
    multiple_choice:
      choices:
        a: |
          Because the function needs to be called multiple times so that multiple
          instances of the component can have their own copy of the data.
        b: |
          Because it's the syntax defined by the Vue developers when designing the
          Options API.
        c: |
          It's not important but it gives us more versatility with regards to what can
          be computed in that initial `data` object.
        d: |
          Because this way, Vue can get every property of such returned object and
          add them as reactive properties to the instance's `this` keyword.
      correct: a

extending_cart_computed_prop:
  question: |
    In Vue, why is it important to avoid having the same information set as
    `data` onto 2 different components?
  explanation: |
    Avoid duplicated data whenever possible. It helps keep your application
    simple and avoid bugs!
  features:
    multiple_choice:
      choices:
        a: |
          Because with duplicated data, our memory footprint is bigger
          than we need.
        b: |
          Because when we have duplicated data, one copy of this data can
          change, while the other remains outdated. This forces us to
          complicate things and add hooks to keep both sides of the data
          up to date.
        c: |
          Because duplicated data is a bad programming technique that should
          be avoided if possible.
        d: |
          Because Vue reactivity has shortcomings when it needs to update a source
          of data that is present twice in your application.
      correct: b

extending_cart_computed_prop_2:
  question: |
    In the video, we showed this computed property, which merges the data
    returned by our watcher with the data that is present in the cart:

    ```javascript
    completeCart() {
        if (!this.cart || !this.products) {
            return null;
        }

        const completeItems = this.cart.items.map((cartItem) => (
            {
                product: this.products.find((product) => product['@id'] === cartItem.product),
                color: cartItem.color,
                quantity: cartItem.quantity,
            }
        ));

        return {
            items: completeItems,
        };
    },
    ```

    Take a closer look at the beginning of this function:

    ```javascript
    if (!this.cart || !this.products) {
        return null;
    }
    ```

    Why are we adding this check here? And what would happen if we didn't have it in place?
  explanation: |
    Indeed, our template *will* work without that check in place... but not before
    the computed function triggers some errors. This could still be ok... but nobody likes
    errors!
  features:
    multiple_choice:
      choices:
        a: |
          Without that check in place, our application won't load. We would see a
          blank page and an error in the console
        b: |
          This check is redundant. It is nice to have it, but our application can
          work just the same without it.
        c: |
          Without that check in place, our application will have errors in
          the console and our template will load, but with some bugs regarding
          reactivity. Data might change in the future that won't be reflected in
          our app.
        d: |
          Without this check, our template won't load until both variables get populated.
          We will have errors in the console, but once the data is loaded, the
          template would render successfully.
      correct: d

extending_parallel_ajax:
  question: |
    What is the advantage of using `await Promise.all()` for fetching more than one
    ajax call in an async function?
  explanation: |
    In the right situation, parallelizing ajax calls can save the user precious
    seconds when the internet connection is not optimal!

    > In our video, we end up taking a different route than `await Promise.all()`
    > just because there are multiple `async created` functions that get called. So
    > the end result is the same: Both calls get executed at almost the same time!
  features:
    multiple_choice:
      choices:
        a: |
          There is no advantage in doing so. `Promise.all()` is just syntax sugar.
          It will make our code more readable and clean.
        b: |
          `Promise.all()` has the ability to launch both ajax calls in parallel.
          Once all calls are completed, the code will continue as normal.
        c: |
          `Promise.all()` lets you organize your ajax calls in a way so that one call
          executes right after the other. This way, your data from the previous call
          is already available by the time you call the next one, which can be useful!
        d: |
          While `Promise.all()` won't give you any significant advantage, it's in general
          a little bit faster than the `async` keyword.
          for reasons of micro-optimizations.
      correct: b

extending_v_for_key:
  question: |
    In this video, we start with a component that iterates through a list of
    items using the items' `index` in the Array as `key`, like so:

    ```vue
    <shopping-cart-item
        v-for="(item, index) in items"
        :key="index"
        :item="item"
    />
    ```

    But this is not ideal! In a real application, each item should have an
    id that is unique to that item for the `key` attribute. But why is this so?
  explanation: |
    Vue uses the `key` attribute to identify unique items in a `v-for` list so that
    it can *only* modify the ones that really change. If the `key` for an item suddenly
    changes, Vue may re-create that component from scratch, causing optimization issues
    and potential data de-syncs.
  features:
    multiple_choice:
      choices:
        a: |
          The `key` becomes the internal id of the object, which is useful because
          it's included when Vue displays an error.
        b: |
          Because if we remove and add items from this list dynamically, the `key`
          for an existing item might change. That could cause Vue to destroy and
          re-create the entire component from scratch instead of reusing the existing
          instance.
        c: |
          Becauase Vue needs proper item ids to be assigned to its DOM nodes. In the
          case of `v-for` where each node comes from `data`, vue is asking for us
          to provide this internal id for them.
        d: |
          No reason, we really can put anything in the `key` attribute as long
          as it's not duplicated. Vue will work its magic under the hood so that
          items get rendered correctly
      correct: b

extending_prop_trap:
  question: |
    Imagine you have this component that renders the name of a Pizza object,
    which you can in turn modify by typing text into an input element:

    ```vue
    <template>
        <label>Name:</table>
        <pizza-name-input :pizza="pizza" />
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import PizzaNameInput from '@/components/pizza-name-input';

    export default {
        name: 'PizzaFormField',
        components: {
            PizzaNameInput,
        },
        data() {
            pizza: null,
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member'];
        },
    };
    </script>
    ```

    ```vue
    <template>
        <input type="text" v-model="pizza.name" />
    </template>

    <script>
    export default {
        name: 'PizzaNameInput',
        props: {
            pizza: {
                type: Object,
                required: true,
            },
        },
    };
    </script>
    ```

    What is the mistake we've just made here?
  explanation: |
    Our code will *still* work in this situation. But we can face weird side
    efefcts when changing either the `prop` or the original `data` object that
    contains the `pizza` object. Props were not designed to be modifiable by
    the component that receives them!
  features:
    multiple_choice:
      choices:
        a: |
          The `v-model` directive only works with `data` properties since `props`
          are read only.
        b: |
          We should be using `v-model.trim` here to get rid of extra white spaces.
          Failing to do this sanitation will end up with our backend database
          getting filled with garbage.
        c: |
          This code will work as it is, but by assigning a prop to a `v-model` directive,
          we're modifying that prop inside our child component. This is in general a bad idea
          and can lead to desync issues. Props were not designed to be modifiable.
        d: |
          Ha! Trick question! There is nothing wrong with this code.
          fine.
      correct: c

extending_emit_update_quantity:
  question: |
    Imagine we have a component that takes a value from the user and emits an
    event when the user changes it:

    ```vue
    <template>
        <input
            :value="pizza.name"
            @input="updatePizzaName"
        />
    </template>

    <script>
    export default {
        name: 'PizzaNameInput',
        props: {
            pizza: {
                type: Object,
                required: true,
            },
        },
        methods: {
            updatePizzaName($event) {
                this.$emit('update-pizza-name', { name: $event.target.value });
            },
        },
    };
    </script>
    ```

    From its parent component, I want to re-emit this event so that I can handle
    it further up the component tree!

    What is the best way of doing this?
  explanation: |
    While most of these options will work (except `d`), the best and simplest way to
    "bubble" an event up is by just using the template function shortcut `$emit` with
    its parameter `$event`!

    > Notice that when bubbling events up, best practices are to keep the event's name
    > the same. This is like when DOM events bubble up, they keep their name and their
    > data intact!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <pizza-name-input @update-pizza-name="$emit('update-pizza-name', $event)" />
          ```
        b: |
          ```vue
          <template>
              <pizza-name-input @update-pizza-name="updatePizzaNameParent" />
          </template>

          <script>
          export default {
              name: 'ParentComponent',
              methods: {
                  updatePizzaNameParent($event) {
                      this.emit('update-pizza-name', $event);
                  },
              },
          };
          </script>
          ```
        c: |
          ```vue
          <pizza-name-input @update-pizza-name="$emit('update-pizza-name-parent', $event)" />
          ```
        d: |
          ```vue
          <pizza-name-input @update-pizza-name="function() { $emit('update-pizza-name', $event); }" />
          ```
      correct: a

extend_add_to_cart_component:
  question: |
    In my pizza app, I have a section of the `show-pizza` component that allows
    the user to order some individual slices!

    Here's how the component looks:

    ```vue
    <template>
        <div
            :class="$style.component"
            v-if="pizza !== null"
        >
            <h1>{{ pizza.name }}</h1>

            <p>{{ pizza.description }}</p>

            <div class="order-buttons">
                <button
                    @click="orderSlices(1)"
                    :disabled="ordering"
                >
                    Order 1 slice!
                </button>

                <button
                    @click="orderSlices(2)"
                    :disabled="ordering"
                >
                    This pizza looks great! Order 2 slices!!
                </button>

                <button
                    @click="orderSlices(4)"
                    :disabled="ordering"
                >
                    I'm starving!! Order 4 slices!!!
                </button>
            </div>
        </div>
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import { orderPizza } from '@/services/order-pizza';

    export default {
        name: 'ShowPizza',
        data() {
            return {
                pizza: null,
                ordering: false,
            };
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member];
        },
        methods: {
            async orderPizza(slices) {
                await orderPizza(slices);
                this.ordered = true;
            },
        },
    };
    </script>

    <style lang="scss" module>
    .component :global {
        overflow: hidden;

        .order-buttons {
            padding-top: 20px;
            margin-top: 20px;
            border-top: 1px solid #FF0000;
        }
    }
    </style>
    ```

    But hey! Pizza headquarters are now asking me to include these ordering buttons EVERYWHERE
    in the app. They had such a good reception!

    I need to extract all the "ordering" logic into a separate component. What would this component
    look like?
  explanation: |
    Extracing functionality and presentation into a component can be tricky! This usually involves
    copying `data`, `props`, `methods`, `computed` properties and even lifecycle functions, apart
    from the obvious template and styles! Make sure you don't forget anything!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      pizza: null,
                      ordering: false,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
              methods: {
                  async orderSlices(slices) {
                      this.ordering = true;
                      await orderPizza(slices);
                      this.ordering = false;
                  },
              },
          };
          </script>

          <style lang="scss" module>
          .component {
              padding-top: 20px;
              margin-top: 20px;
              border-top: 1px solid #FF0000;
          }
          </style>
          ```
        b: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      ordering: false,
                  };
              },
              methods: {
                  async orderSlices(slices) {
                      this.ordering = true;
                      await orderPizza(slices);
                      this.ordering = false;
                  },
              },
          };
          </script>

          <style lang="scss" module>
          .component {
              padding-top: 20px;
              margin-top: 20px;
              border-top: 1px solid #FF0000;
          }
          </style>
          ```
        c: |
          ```vue
          <template>
              <div class="order-buttons">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      ordering: false,
                  };
              },
              methods: {
                  async orderSlices(slices) {
                      this.ordering = true;
                      await orderPizza(slices);
                      this.ordering = false;
                  },
              },
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <div class="order-buttons">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      ordering: false,
                  };
              },
          };
          </script>

          <style lang="scss" module>
          .component {
              padding-top: 20px;
              margin-top: 20px;
              border-top: 1px solid #FF0000;
          }
          </style>
          ```
      correct: b

extending_cart_controls_component2:
  question: |
    Here's the same component from the last challenge:

    ```vue
    <template>
        <div
            :class="$style.component"
            v-if="pizza !== null"
        >
            <h1>{{ pizza.name }}</h1>

            <p>{{ pizza.description }}</p>

            <div class="order-buttons">
                <button
                    @click="orderSlices(1)"
                    :disabled="ordering"
                >
                    Order 1 slice!
                </button>

                <button
                    @click="orderSlices(2)"
                    :disabled="ordering"
                >
                    This pizza looks great! Order 2 slices!!
                </button>

                <button
                    @click="orderSlices(4)"
                    :disabled="ordering"
                >
                    I'm starving!! Order 4 slices!!!
                </button>
            </div>
        </div>
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import { orderPizza } from '@/services/order-pizza';

    export default {
        name: 'ShowPizza',
        data() {
            return {
                pizza: null,
                ordering: false,
            };
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member];
        },
        methods: {
            async orderPizza(slices) {
                this.ordering = true;
                await orderPizza(slices);
                this.ordering = false;
            },
        },
    };
    </script>

    <style lang="scss" module>
    .component :global {
        overflow: hidden;

        .order-buttons {
            padding-top: 20px;
            margin-top: 20px;
            border-top: 1px solid #FF0000;
        }
    }
    </style>
    ```

    We've just moved its order buttons logic into an outside component called `order-buttons`!
    After including the `order-buttons` component, how would this component look like?
  explanation: |
    As important as being accurate when extracting logic to an external component is
    to *remove* the left overs so that you don't end up with repeated `data` or `props`!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import { orderPizza } from '@/services/order-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;
          }
          </style>
          ```
        b: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                      ordered: false,
                      ordering: false,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;
          }
          </style>
          ```
        c: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;
          }
          </style>
          ```
        d: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;

              .order-buttons {
                  padding-top: 20px;
                  margin-top: 20px;
                  border-top: 1px solid #FF0000;
              }
          }
          </style>
          ```
      correct: c

extending_smart_watcher:
  question: |
    What are deep watchers useful for?
  explanation: |
    In complex objects where you need to execute watchers over multiple
    nested properties, deep watchers are the answer. The reason this is
    not Vue's default behavior is that deep watchers are harder to
    process!
  features:
    multiple_choice:
      choices:
        a: |
          Deep watchers are used for large objects or arrays where
          we need a more optimized and faster method for watching
          property changes
        b: |
          Deep watchers are used when the watched object is not a
          simple data type (i.e. `Number`, `String` or `Boolean`)
        c: |
          Deep watchers are used when you need to watch changes in
          complex objects, where nested properties might change.
      correct: c

extending_smart_watcher_2:
  question: |
    In this component, I'm using a watcher to check changes in
    the pizza object in my component's `data`. But some of the
    changes are not triggering a watch!!

    ```vue
    <template>
        // Some fancy template here!
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import { executeFancyWatcherLogicHere } from '@/some/crazy/path';

    export default {
        name: 'PizzaComponent',
        data() {
            return {
                pizza: null;
            };
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member'];
        },
        watch: {
            async pizza() {
                await executeFancyWatcherLogicHere();
            },
        },
    };
    </script>
    ```

    I'm thinking that since pizza is a complex object, once it loads,
    I need to switch the watcher to be a deep watcher. What is the
    correct way to do it?
  explanation: |
    Remember that watchers have 2 syntaxes: They can be a function,
    with the name of the property to watch, or they can be an object
    with options!

    > There are more options to watchers than what we've seen here!
    > You can refer to Vue's documentation to see what those are.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          watch: {
              pizza: {
                  deep: true,
                  handler() {
                      executeFancyWatcherLogicHere();
                  },
              },
          },
          ```
        b: |
          ```javascript
          watch: {
              pizza() {
                  this.setDeep = true;
                  executeFancyWatcherLogicHere();
              },
          },
          ```
        c: |
          ```javascript
          watch: {
              pizza: {
                  deep: true,
                  watcher() {
                      executeFancyWatcherLogicHere();
                  },
              },
          },
          ```
        d: |
          ```javascript
          watch: {
              pizza: {
                  deepWatcher() {
                      executeFancyWatcherLogicHere();
                  },
              },
          },
          ```
      correct: a

extending_css_transitions:
  question: |
    Imagine I have a simple component that can show a message when one of our
    customers has bought too much pizza.

    ```vue
    <template>
        <div :class="{
                [$style.component]: true,
                [$style.tall]: showDisclaimer,
            }"
        >
            <button @click="addPizzaToCart" />

            <p v-show="showDisclaimer">
                <strong>Disclaimer</strong>: Eating too much pizza can be
                bad for your health!
            </p>
        </div>
    </template>

    <script>
    import { buyPizza } from '@/services/buy-pizza';

    export default {
        name: 'PizzaCheckout',
        data() {
            return {
                pizzaCount: 0,
                showDisclaimer: false,
            };
        },
        methods: {
            async addPizzaToCart() {
                await buyPizza();

                this.pizzaCount++;
                if (this.pizzaCount > 10) {
                    this.showDisclaimer = true;
                }
            }
        },
    };
    </script>
    ```

    In an application where this component has a fixed height, I want to
    add some styling so that its height will *transition* smoothly when that message
    toggles on and off.

    Which `style` tag would be good for the job?
  explanation: |
    Don't forget to transition the element's `height` property and provide good values
    through the different classes!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <style lang="scss" module>
          .component {
              height: 200px;

              &.tall {
                  height: 400px;
              }
          }
          </style>
          ```
        b: |
          ```vue
          <style lang="scss" module>
          .component {
              height: 200px;
              transition: height;

              &.tall {
                  height: 400px;
              }
          }
          </style>
          ```
        c: |
          ```vue
          <style lang="scss" module>
          .component {
              height: 200px;
              transition: height 1s;

              &.tall {
                  height: 400px;
              }
          }
          </style>
          ```
        d: |
          ```vue
          <style lang="scss" module>
          .component {
              height: 200px;
              transition: height 1s;
          }
          </style>
          ```
      correct: c

extending_css_transitions_2:
  question: |
    Imagine I have this element in a template that I'm transitioning to fade in and out:

    ```vue
    <template>
        <div :class="$style.component">
            <transition>
                <p v-show="showDisclaimer" class="transition-class">
                    <strong>Disclaimer</strong>: Eating too much pizza can be
                    bad for your health!
                </p>
            </transition>
        </div>
    </template>

    <style lang="scss" module>
    .component :global {
        .transition-testing {
            transition: opacity 1s;
        }
    }
    </style>
    ```

    When we transition an element's opacity and try to show or hide this
    element using `v-show`, our transition breaks as shown in the video.
    Why is this so?
  explanation: |
    Since `v-show` changes the `display` property from `none` to `inherit`,
    our transition over the `opacity` property has no effect in the DOM - the transition is not actually changing!
    Notice that transitioning over the `display` property does not provide
    a fading effect as we'd expect. You can transition over many CSS properties, but
    display *cannot* be transitioned.
    Vue transitions later.
  features:
    multiple_choice:
      choices:
        a: |
          Because Vue's `v-show` directive overrides any class that deals
          with an element's opacity or display properties.
        b: |
          Because Vue's `v-show` directive cancels any transition rules
          that we apply to the element.
        c: |
          Because Vue's `v-show` directive makes the `opacity` property
          jump from `1` to `0` immediately.
        d: |
          Because Vue's `v-show` directive works on the `display` property
          of an element, which is not the property we're transitioning.
      correct: d

extending_transitions:
  question: |
    Our component that shows or hides a disclaimer message upon buying
    pizza slices has made a big impact in our customer's health! Yay!

    But our CEO is not very happy with the visual results... Nay!

    They now wants us to just fade in or out the message text itself (instead of
    adjusting the height) when a user wants to buy too much pizza. We can use
    Vue transitions for that!

    Here's the initial component's template:

    ```html
    <template>
        <div>
            <button @click="addPizzaToCart" />

            <p v-show="showDisclaimer">
                <strong>Disclaimer</strong>: Eating too much pizza can be
                bad for your health!
            </p>
        </div>
    </template>
    ```

    How can we make it work using Vue transitions?
  explanation: |
    Using Vue transitions can seem a bit complicated at first, but it's
    really a very useful feature once you get to know it! A lot like driving a
    manual transmission (yes, this is a skill that many of Americans - like me! - completely lack).

    Remember the classes it relies on have to be under the `:global` keyword,
    otrherwise your transition won't work where the class names have been
    altered!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button @click="addPizzaToCart" />

                 <transition>
                      <p v-show="showDisclaimer">
                          <strong>Disclaimer</strong>: Eating too much pizza can be
                          bad for your health!
                      </p>
                 </transition>
              </div>
          </template>

          <style lang="scss" module>
          .component :global {
              .v-enter, .v-leave {
                  opacity: 0;
              }
          }
          </style>
          ```
        b: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button @click="addPizzaToCart" />

                  <transition>
                      <p v-show="showDisclaimer">
                          <strong>Disclaimer</strong>: Eating too much pizza can be
                          bad for your health!
                      </p>
                  </transition>
              </div>
          </template>

          <style lang="scss" module>
          .component :global {
              .v-enter-active, .v-leave-active {
                  transition: opacity 1s;
              }

              .v-enter, .v-leave {
                  opacity: 0;
              }
          }
          </style>
          ```
        c: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button @click="addPizzaToCart" />

                  <transition>
                      <p v-show="showDisclaimer">
                          <strong>Disclaimer</strong>: Eating too much pizza can be
                          bad for your health!
                      </p>
                  </transition>
              </div>
          </template>

          <style lang="scss" module>
          .component {
              .v-enter-active, .v-leave-active {
                  transition: opacity 1s;
              }

              .v-enter, .v-leave {
                  opacity: 0;
              }
          }
          </style>
          ```
        d: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button @click="addPizzaToCart" />

                  <p v-show="showDisclaimer" transition>
                      <strong>Disclaimer</strong>: Eating too much pizza can be
                      bad for your health!
                  </p>
              </div>
          </template>

          <style lang="scss" module>
          .component :global {
              .v-enter-active, .v-leave-active {
                  transition: opacity 1s;
              }

              .v-enter, .v-leave {
                  opacity: 0;
              }
          }
          </style>
          ```
      correct: b

extending_transition_name:
  question: |
    What does the transition `name` property do?
  explanation: |
    Having several transitions forces us to use `names` so that we can have well
    defined classes defining them!
  features:
    multiple_choice:
      choices:
        a: |
          It names the transition so that we can track it in the Vue Dev Tools
          should we need to debug it.
        b: |
          It changes the name of the transition classes for a given transition
          so you can have different transitions in your application with different
          names.
        c: |
          Name doesn't really do anything. It's just a standard DOM attribute we
          can use to select elements in the DOM.
        d: |
          The `name` property in a transition corresponds to the name of the component
          they are being used in. It's not mandatory, but it's nice to add it.
      correct: b

extending_transition_name_2:
  question: |
    Vue transitions have also a `mode` attribute. The default for a transition
    in Vue is that both transitions happen simultaneously.

    What happens when we set the `mode` attribute to be `out-in`?
  explanation: |
    In cases where swapping DOM elements that ought to occupy the same space,
    but don't have absolute positioning, sometimes it's better to use the `out-in`
    mode, so that one component can fade out *before* the other component fades in!
    There is also `in-out` where the opposite happens!
  features:
    multiple_choice:
      choices:
        a: |
          When setting `out-in`, our component will fade out before the other component
          starts fading in!
        b: |
          When setting `out-in`, our component will fade in before the other component
          starts fading out!
        c: |
          When setting `out-in`, both components will fade in/out at the same time
      correct: a

extending_prop_transition:
  question: |
    In this video, we talk about adding a `key` attribute to a component so that
    we can transition its appearance when a prop changes.

    ```html
    <transition
        name="fade"
        mode="out-in"
    >
        <title
            :key="currentState"
            :text="pageTitle"
        />
    </transition>
    ```

    How does this work?
  explanation: |
    Using `key` on a component makes Vue destroy and recreate it when that prop changes.
    change. This works in our scenario, but it might lead to issues if the
    component has some data that needs to be saved between states.
  features:
    multiple_choice:
      choices:
        a: |
          Vue transitions look for the `key` attribute of a component so that it
          can detect changes to it and operate transitions.
        b: |
          By adding a `key` attribute, we are telling Vue that it should recursively
          look into `props`, `data` and `computed` so that it can trigger the transition
          if any of these things change.
        c: |
          Trick question! It's really the `text` attribute we're transitioning over,
          Vue detects its change and makes it work!
        d: |
          By adding a `key` attribute, Vue destroys and recreates the component every
          time the value of `key` changes. This means that we now have effectively 2
          components to transition over!
      correct: d

extending_checkout_form:
  question: |
    In summary, what does `v-model` do to an `input` element when we add to it?
  explanation: |
    On a high level, the job of `v-model` is to keep the some piece of data in sync between the UI and the
    data. Soon we'll learn *exactly* how Vue does this!
  features:
    multiple_choice:
      choices:
        a: |
          `v-model` creates a model of an input element that corresponds to an object.
          In this object we can set styles, properties and the input's value.
        b: |
          `v-model` triggers events at certain points of the application life cycle so
          that an input element can load a piece of data.
        c: |
          `v-model` ensures that our input element stays in sync with the data element we
          pass to it.
        d: |
          `v-model` triggers keyboard events at all times so that we can update our
          data according to an input element's value.
      correct: c

extending_checkout_form2:
  question: |
    `v-model` has some "modifiers" we can add to it that change the way
    we process data as it is entered.

    Which of these options is *not* a valid `v-model` modifier?
    Vue tutorials?
  explanation: |
    So far we've covered `v-model.number` and `v-model.trim`. There is another
    modifier, `v-model.lazy`, which only updates our data once the input looses
    focus (as opposed to listening to every key up).

    > Vue 3 now supports custom modifiers, which are modifiers that you can
    > implement as functions, pretty much like *twig* and its custom filters!
    > `v-model.capitalize` is one such example given in the docs, but it's
    > not native to Vue!
  features:
    multiple_choice:
      choices:
        a: |
          `v-model.trim`: this removes all spaces before and after
          the value entered in an input element.
        b: |
          `v-model.capitalize`: this capitalizes every word entered
          in an input element.
        c: |
          `v-model.number`: this parses the value into a JavaScript
          `Number` type.
      correct: b

extend_v_model_custom_component:
  question: |
    We are in the process of building a nice checkout form for our pizza customers.
    It looks something like this:

    ```html
    <template>
        <form>
            <p>Please, enter your info here:</p>

            <fancy-input
                id="name"
                v-model="client.name"
                label="Name:"
            />
        </form>
    </template>
    ```

    We have just written the first input for the customer's name and we want it
    to be a custom component. But we've forgotten how to implement `v-model` in
    a custom component in Vue 2!

    Which of these templates in `fancy-input.vue` would do the trick, assuming our component has a prop
    `value` of type `String`?
  explanation: |
    In vue 2, `v-model` translates to:

    ```html
    <fancy-input
       :value="client.name"
       @input="$emit('input', $event.target.value)
    />
    ```

    Just remember that in Vue 3, the default prop to be used in `v-model` is `modelValue`!

    > Alternatively, you can also pass `v-model:value` in Vue 3. The `:value` part
    > acts as a parameter of the `v-model` *"function"* and tells it that
    > the prop we want to use is called `value`. Just like in Vue 2!
  features:
    multiple_choice:
      choices:
        a: |
          ```html
          <input
              type="text"
              :value="value"
              @input="$emit('input', $event.target.value)"
          >
          ```
        b: |
          ```html
          <input
              type="text"
              :value="value"
              @input="$emit('input', $event)"
          >
          ```
        c: |
          ```html
          <input
              type="text"
              :value="value"
              @change="$emit('input', $event.target.value)"
          >
          ```
        d: |
          ```html
          <input
              type="text"
              :value="value"
              @keyup="$emit('input', $event.target.value)"
          >
          ```
      correct: a
extend_v_bind_object:
  question: |
    `v-bind` is an amazing shortcut that lets us assign multiple, or even dynamic
    props to a component using one single attribute. Given this piece of code,
    what are the actual props that the child component will receive?

    ```html
    <template>
        <child-component
            text="Some text prop here"
            v-bind="{
                isValid: true,
                showText: true,
            }"
        />
    </template>
    ```
  explanation: |
    The fact that `v-bind` is so flexible is a great feature of Vue. You can
    mix `v-bind` with regular props and get both passed down to the child
    component.
  features:
    multiple_choice:
      choices:
        a: |
          ```
          {
              isValid: true,
              showText: true,
          }
          ```
        b: |
          ```
          {
              text: 'Some text prop here',
          }
          ```
        c: |
          ```
          {
              isValid: true,
              showText: true,
              text: 'Some text prop here',
          }
          ```
      correct: c

extending_checkout_submit:
  question: |
    In this video, we show a neat trick that we can do when submitting a form
    in Vue:

    ```html
    <form @submit.prevent="onSubmit">
        ...
    </form>
    ```

    What exactly does the modifier `prevent` do?
  explanation: |
    Event listeners in Vue have several modifiers, of which `prevent` is
    the most useful!
  features:
    multiple_choice:
      choices:
        a: |
          It prevents our component from breaking if there are any errors
          in our callback. It's essentially like wrapping the call with
          a `try...catch`.
        b: |
          It prevents other handlers from being executed on that same event,
          making our callback function exclusive.
        c: |
          It calls `event.preventDefault()` and `event.stopPropagation()` before
          calling our callback function, which means that the default behavior
          for that event (the form submitting) won't take place and the event won't bubble up.
        d: |
          It calls `event.preventDefault()` before calling our callback
          function, which means that the default behavior for that event (the form submitting)
          won't take place.
      correct: d
