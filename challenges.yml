extending_currentproductid:
  question: |
    What is the proper way to pass a JavaScript variable into your app via the template?
  explanation: |
    Remember to always escape your data so that you don't bump into JavaScript errors
    if your variable contains things like quotes!
  features:
    multiple_choice:
      choices:
        a: |
          ```twig
          <script>
             var mySharedVariable = '{{ mySharedValue }}';
          </script>
          ```
        b: |
          ```twig
          <script>
             window.mySharedVariable = '{{ mySharedValue|e('js') }}';
          </script>
          ```
        c: |
          ```twig
          <script>
             window.mySharedVariable = '{{ mySharedValue }}';
          </script>
          ```
        d: |
          ```twig
          <script>
              mySharedVariable = '{{ mySharedValue|e('js') }}';
          </script>
          ```
      correct: b

extending_dynamic_component:
  question: |
    Say we have 2 components and we need to dynamically render them based on
    a condition. One of them will be rendered if we have information about a
    pizza's topping, while the other will be rendered if such information is
    null.

    Here's our component with the two sub components rendered using a `v-if`
    directive:

    ```vue
    <template>
        <pizza-list v-if="pizzaTopping === null" />

        <pizza-description v-if="pizzaTopping !== null" />
    </template>

    <script>
    import PizzaList from '@/components/pizza-list';
    import PizzaDescription from '@/components/pizza-description';
    import { getPizzaToppingInfo } from '@/helpers/get-pizza-topping-info';

    export default {
        name: 'PizzaPage',
        data() {
            return {
                pizzaTopping: getPizzaToppingInfo(),
            };
        },
        computed: {
            dynamicComponent() {
                return this.pizzaTopping === null ? PizzaList : PizzaDescription;
            }
        },
    };
    </script>
    ```

    How can we the `dynamicComponent` computed property to to
    render the correct component based on `this.pizzaTopping`?
  explanation: |
    The dynamic component has the the special `is` prop that, when used *dynamically*
    (like `:is`), can render one component or another based on its value!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <component :is="dynamicComponent" />
          </template>
          ```
        b: |
          ```vue
          <template>
              <component is="dynamicComponent" />
          </template>
          ```
        c: |
          ```vue
          <template>
              <component :pizza-list="dynamicComponent" />
          </template>
          ```
        d: |
          ```vue
          <template>
              <component
                  :pizza-list="!dynamicComponent"
                  :pizza-description="dynamicComponent"
              />
          </template>
          ```
      correct: a

extending_ajax_delay_rendering:
  question: |
    Which of the following will result in an
    Ajax call that's executed *as soon as possible* and then set the
    returned value onto a piece of data?
  explanation: |
    The first place in our component where we can make
    Ajax calls is our `created` function!

    Notice there's nothing technically wrong with making an Ajax call outside
    of the component definition itself, but it will make things...
    well... complicated! In theory, you risk getting a value even
    *before* the component has been instantiated. Instead, use `created`:
    that's the whole point of that hook function!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          const myStoredData;
          myAjaxCallFunction().then((response) => {
              myStoredData = response.data['hydra:member'];
          });

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData,
                  };
              },
          };
          ```
        b: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData: null,
                  };
              },
              async beforeMount() {
                  this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
              },
          };
          ```
        c: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData: null,
                  };
              },
              async created() {
                  this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
              },
          };
          ```
        d: |
          ```javascript
            import { myAjaxCallFunction } from '@/services/my-service';

            export default {
                name: 'MyComponent',
                data() {
                    return {
                        myStoredData: null,
                    };
                },
                async mounted() {
                    this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
                },
            };
            ```
      correct: c

extending_product_template:
  question: |
    Imagine that our product template has a section that is wrapped
    in a `v-if` directive, only to be shown if `product !== null`, as shown
    in this lesson.

    ```vue
    <template>
        <div :class="$style.component">
            <loading v-show="loading" />

            <h1 v-if="product !== null">{{ product.title }}</h1>
        </div>
    </template>

    <script>
    export default {
        name: 'ProductComponent',
        data() {
            return {
                loading: true,
                product: null,
            };
        },
        // Some more computed, life cycle functions and methods here
    };
    </script>
    ```

    What would happen if we removed this `v-if` and let the page
    render either way?
  explanation: |
    While our app *would* work once `product` loads,
    we will be getting errors in the console because our `product` object is
    `null` when the component first instantiates.

    The errors come from this brief moment when our application tries to render
    but its data still hasn't loaded. Once it loads, though, reactivity makes it
    so that the component re-renders: this time with all the information it needs.
  features:
    multiple_choice:
      choices:
        a: |
          We would have render errors in our App, preventing the component from
          rendering
        b: |
          Our App could crash, making the browser unresponsive
        c: |
          The App would work just the same, rendering once our data has loaded
        d: |
          We would have errors in the console, for example, indicating that
          `product.title` is `undefined`, but it *would* still render once the
          `product` data became available.
      correct: d

extending_add_to_cart:
  question: |
    Imagine we have a component whose sole purpose is to render an input element:

    ```vue
    <template>
        <input type="text" v-model="myValue" />
    </template>

    <script>
    export default {
        name: 'InputComponent',
        data() {
            return {
                myValue: '',
            };
        },
    };
    </script>
    ```

    Which of the following `:disabled` attributes would result in an input element
    being *disabled*?
  explanation: |
    According to Vue documentation:

    ```
    If [ the value of a `disabled` attribute ] has the value of null, undefined,
    or false, the `disabled` attribute will not even be included in the rendered
    <button> element.
    ```

    This implies that any string value will evaluate to `true`!

    > Note that `someUndefinedVariable` is undefined since I haven't defined it in the object's
    > `data` or `props`. This *will* throw a warning in the console, but the return value
    > is still `undefined`.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <input :disabled="'0'" />
          ```
        b: |
          ```vue
          <input :disabled="false" />
          ```
        c: |
          ```vue
          <input :disabled="null" />
          ```
        d: |
          ```vue
          <input :disabled="someUndefinedVariable" />
          ```
      correct: a

extending_cart_loading_quantity:
  question: |
    Imagine we wrote a component that needs to take a number and send its value plus 2
    to my database (a VERY useful scenario, I know!):

    ```vue
    <template>
        <input
            type="number"
            v-model="theNumber"
            min="1"
        />

        <button @click="sendNumber">
            Send!
        </button>
    </template>

    <script>
    import { saveNumber } from '@/services/save-number';

    export default {
        name: 'MyComponent',
        data() {
            return {
                theNumber: 0,
            };
        },
        methods: {
            sendNumber() {
                saveNumber(this.theNumber + 2);
            },
        },
    };
    </script>
    ```

    But, oh! I've just discovered that there is a massive bug in this code!
    When I entered the number `1`, it saved the number `12` instead of `3`!
    What is the best way to fix this?
  explanation: |
    The *best* way to fix this is by using the directive attribute
    `number`! This will take care of all the number conversions for us
    under the hood. We'll never have to worry about it!

    > Option `a` will still work, but `v-model.number` does the same work for us
    > out of the box! Option `b` is a syntax error, and `d` might just hang your browser!!
  features:
    multiple_choice:
      choices:
        a: |
          methods: {
              sendNumber() {
                  saveNumber(parseInt(this.theNumber) + 2);
              },
          },
        b: |
          ```vue
          <input
              type="number"
              v-model.parseInt="theNumber"
              min="1"
          />
          ```
        c: |
          ```vue
          <input
              type="number"
              v-model.number="theNumber"
              min="1"
          />
          ```
        d: |
          ```vue
          <input
              type="number"
              v-model="theNumber"
              @input="$event.target.value=parseInt(theNumber)"
              min="1"
          />
          ```
      correct: c


extending_webpack_entry:
  question: |
    Suppose we have a Symfony project that uses Webpack Encore. We've just finished
    building a new Vue component, but we only want to render it on a specific page.
    And so, we've decided to create a new Webpack entry.

    Which of the following options is not something that we need to do to accomplish this?
  explanation: |
    The 3 steps to creating a new Webpack entry that renders a Vue component are:
    - The .vue file with the component itself
    - A Controller that renders a Twig template, which includes a JavaScript file that
      renders the app inside this template
    - An entry in `webpack.config.js` to build our application.

    And while passing variables into our Vue component through the template is *nice*,
    it's not always needed!
  features:
    multiple_choice:
      choices:
        a: |
          A new `.vue` file to hold the new, main component
        b: |
          A `javascripts` block in the Twig template that contains different configurations
          and values to be used by our Vue App
        c: |
          A Controller, a Twig template and JavaScript file that will be loaded by the browser
          to instantiate the main component.
        d: |
          An `addEntry` call in `webpack.config.js` to tell webpack that it should build the file.
          a new entry.
    correct: b

extending_webpack_entry_2:
  question: |
    Which of these JavaScript file examples will succeed in rendering a Vue component
    in `Vue 2` inside an element with id `app`?
  explanation: |
    This bit of JavaScript code can be quite tricky to remember (and
    it does change slightly in Vue 3)!

    Thankfully we have the Vue documentation site to refresh our memory if any of these
    nuances get lost in forgotten-land!

    > In Vue 3, the code changes to:
    > ```vue
        import { createApp } from 'vue';
        import App from '@/pages/my-page.vue';

        const App = createApp(App);

        App.mount('#app');
    >  ```
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          });
          ```
        b: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$mount('#app');
          ```
        c: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$render('#app');
          ```
        d: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          }).$mount('#app');
          ```
      correct: d

extending_mixin_basics:
  question: |
    Which of the following is *not* true about mixins?
  explanation: |
    Mixins are a *great* way to share logical functionality between
    components! They do not, however, have the ability to extend markup or
    styles. For that, just use regular components!
  features:
    multiple_choice:
      choices:
        a: |
          Mixins can help you share information between components, such as
          data attributes and even props!
        b: |
          Mixins can be useful for sharing methods and computed properties
          between components. Its properties and methods will be automatically
          available to other methods and even the template of the component
          you share it with!
        c: |
          Mixins are a great way to extend the template or styles in a component.
          The mixin template will be added to the component's template at the bottom, and styles
          will be automatically applied to any elements you provide styles for!
        d: |
          Mixins can help you with lifecycle behavior. By adding lifecycle functions
          to a mixin, those will be executed before any of your own component's
          lifecycle functions without replacing them! Sweet!
      correct: c

extending_more_mixin:
  question: |
    Take a look at these two components. Then choose which option below correctly shows
    a mixin that will allow them to remove their duplicated logic.

    ```vue
    <template>
        <h1>{{ pizzaName }}</h1>
        <p>{{ pizza.description }}</p>
        <ul>
            <li
                v-for="ingredient in pizza.ingredientes"
                :key="ingredient['@id']"
            >
                {{ ingredient.name }}
            </li>
        </ul>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaName() {
                return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```

    ```vue
    <template>
        <table v-if="pizza !== null">
            <tr>
                <td>{{ pizzaDescription }}</td>
                <td>{{ pizza.price }} </td>
            </tr>
        </table>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaDescription() {
                return this.pizza.name +  ' ' + pizza.description;
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```
  explanation: |
    The only data that is really shared between the components is the `pizza` data
    object and the `created` function. Everything else is unique to each component
    and so extracting it to a mixin does *not* make the most sense.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              }
          };
          ```
        b: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
        c: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
              },
          };
          ```
        d: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
      correct: a

extending_more_mixin_2:
  question: |
    Say I have this very simple counter component:

    ```vue
    <template>
        <div v-text="count" />
    </template>

    <script>
    export default {
        name: 'CounterComponent',
        data() {
            return {
                count: 0,
            };
        },
    };
    </script>
    ```

    Why is it important that data is a *function* that returns an object?
    Why can't data be set directly to the `{ count: 0 }` object?
  explanation: |
    As mentioned in Vue documentation, the reason why Vue needs
    data to be a function os so that each instance of the component can
    maintain a different copy of this data.

    This doesn't happen with `props` however, where we define each prop inside the
    `props` object, but we don't make it a function! the reason `props` doesn't
    need to be inside a function is because they don't really hold data. It's
    data is either passed down by other components on initialization, or defined
    by our `default` keyword.
  features:
    multiple_choice:
      choices:
        a: |
          Because the function needs to be called multiple times so that multiple
          instances of the component can have their own copy of the data.
        b: |
          Because it's the syntax defined by the Vue developers when designing the
          Options API.
        c: |
          It's not important but it gives us more versatility with regards to what can
          be computed in that initial `data` object.
        d: |
          Because this way, Vue can get every property of such returned object and
          add them as reactive properties to the instance's `this` keyword.
      correct: a
