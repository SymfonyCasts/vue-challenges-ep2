extending_currentproductid:
  question: |
    What is the proper way to pass a JavaScript variable into your app via the template?
  explanation: |
    Remember to always escape your data so that you don't bump into JavaScript errors
    if your variable contains things like quotes!
  features:
    multiple_choice:
      choices:
        a: |
          ```twig
          <script>
             var mySharedVariable = '{{ mySharedValue }}';
          </script>
          ```
        b: |
          ```twig
          <script>
             window.mySharedVariable = '{{ mySharedValue|e('js') }}';
          </script>
          ```
        c: |
          ```twig
          <script>
             window.mySharedVariable = '{{ mySharedValue }}';
          </script>
          ```
        d: |
          ```twig
          <script>
              mySharedVariable = '{{ mySharedValue|e('js') }}';
          </script>
          ```
      correct: b

extending_dynamic_component:
  question: |
    Say we have 2 components and we need to dynamically render them based on
    a condition. One of them will be rendered if we have information about a
    pizza's topping, while the other will be rendered if such information is
    null.

    Here's our component with the two sub components rendered using a `v-if`
    directive:

    ```vue
    <template>
        <pizza-list v-if="pizzaTopping === null" />

        <pizza-description v-if="pizzaTopping !== null" />
    </template>

    <script>
    import PizzaList from '@/components/pizza-list';
    import PizzaDescription from '@/components/pizza-description';
    import { getPizzaToppingInfo } from '@/helpers/get-pizza-topping-info';

    export default {
        name: 'PizzaPage',
        data() {
            return {
                pizzaTopping: getPizzaToppingInfo(),
            };
        },
        computed: {
            dynamicComponent() {
                return this.pizzaTopping === null ? PizzaList : PizzaDescription;
            }
        },
    };
    </script>
    ```

    How can we use the `dynamicComponent` computed property to
    render the correct component based on `this.pizzaTopping`?
  explanation: |
    The dynamic component has the the special `is` prop that, when used *dynamically*
    (like `:is`), can render one component or another based on its value!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <component :is="dynamicComponent" />
          </template>
          ```
        b: |
          ```vue
          <template>
              <component is="dynamicComponent" />
          </template>
          ```
        c: |
          ```vue
          <template>
              <component :pizza-list="dynamicComponent" />
          </template>
          ```
        d: |
          ```vue
          <template>
              <component
                  :pizza-list="!dynamicComponent"
                  :pizza-description="dynamicComponent"
              />
          </template>
          ```
      correct: a

extending_ajax_delay_rendering:
  question: |
    Which of the following will result in an
    Ajax call that's executed *as soon as possible* and then set the
    returned value onto a piece of data?
  explanation: |
    The first place in our component where we can make
    Ajax calls is our `created` function!

    Notice there's nothing technically wrong with making an Ajax call outside
    of the component definition itself, but it will make things...
    well... complicated! In theory, you risk getting a value even
    *before* the component has been instantiated. Instead, use `created`:
    that's the whole point of that hook function!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          const myStoredData;
          myAjaxCallFunction().then((response) => {
              myStoredData = response.data['hydra:member'];
          });

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData,
                  };
              },
          };
          ```
        b: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData: null,
                  };
              },
              async beforeMount() {
                  this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
              },
          };
          ```
        c: |
          ```javascript
          import { myAjaxCallFunction } from '@/services/my-service';

          export default {
              name: 'MyComponent',
              data() {
                  return {
                      myStoredData: null,
                  };
              },
              async created() {
                  this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
              },
          };
          ```
        d: |
          ```javascript
            import { myAjaxCallFunction } from '@/services/my-service';

            export default {
                name: 'MyComponent',
                data() {
                    return {
                        myStoredData: null,
                    };
                },
                async mounted() {
                    this.myStoredData = (await myAjaxCallFunction()).data['hydra:member'];
                },
            };
            ```
      correct: c

extending_product_template:
  question: |
    Imagine that our product template has a section that is wrapped
    in a `v-if` directive, only to be shown if `product !== null`, as shown
    in this lesson.

    ```vue
    <template>
        <div :class="$style.component">
            <loading v-show="loading" />

            <h1 v-if="product !== null">{{ product.title }}</h1>
        </div>
    </template>

    <script>
    export default {
        name: 'ProductComponent',
        data() {
            return {
                loading: true,
                product: null,
            };
        },
        // Some more computed, life cycle functions and methods here
    };
    </script>
    ```

    What would happen if we removed this `v-if` and let the page
    render either way?
  explanation: |
    While our app *would* work once `product` loads,
    we will be getting errors in the console because our `product` object is
    `null` when the component first instantiates.

    The errors come from this brief moment when our application tries to render
    but its data still hasn't loaded. Once it loads, though, reactivity makes it
    so that the component re-renders: this time with all the information it needs.
  features:
    multiple_choice:
      choices:
        a: |
          We would have render errors in our App, preventing the component from
          rendering
        b: |
          Our App could crash, making the browser unresponsive
        c: |
          The App would work just the same, rendering once our data has loaded
        d: |
          We would have errors in the console, for example, indicating that
          `product.title` is `undefined`, but it *would* still render once the
          `product` data became available.
      correct: d

extending_add_to_cart:
  question: |
    Imagine we have a component whose sole purpose is to render an input element:

    ```vue
    <template>
        <input type="text" v-model="myValue" />
    </template>

    <script>
    export default {
        name: 'InputComponent',
        data() {
            return {
                myValue: '',
            };
        },
    };
    </script>
    ```

    Which of the following `:disabled` attributes would result in an input element
    being *disabled*?
  explanation: |
    According to Vue documentation:

    ```
    If [ the value of a `disabled` attribute ] has the value of null, undefined,
    or false, the `disabled` attribute will not even be included in the rendered
    <button> element.
    ```

    This implies that any string value will evaluate to `true`!

    > Note that `someUndefinedVariable` is undefined since I haven't defined it in the object's
    > `data` or `props`. This *will* throw a warning in the console, but the return value
    > is still `undefined`.
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <input :disabled="'0'" />
          ```
        b: |
          ```vue
          <input :disabled="false" />
          ```
        c: |
          ```vue
          <input :disabled="null" />
          ```
        d: |
          ```vue
          <input :disabled="someUndefinedVariable" />
          ```
      correct: a

extending_cart_loading_quantity:
  question: |
    Imagine we wrote a component that needs to take a number and send its value plus 2
    to my database (a VERY useful scenario, I know!):

    ```vue
    <template>
        <input
            type="number"
            v-model="theNumber"
            min="1"
        />

        <button @click="sendNumber">
            Send!
        </button>
    </template>

    <script>
    import { saveNumber } from '@/services/save-number';

    export default {
        name: 'MyComponent',
        data() {
            return {
                theNumber: 0,
            };
        },
        methods: {
            sendNumber() {
                saveNumber(this.theNumber + 2);
            },
        },
    };
    </script>
    ```

    But, oh! I've just discovered that there is a massive bug in this code!
    When I entered the number `1`, it saved the number `12` instead of `3`!
    What is the best way to fix this?
  explanation: |
    The *best* way to fix this is by using the directive attribute
    `number`! This will take care of all the number conversions for us
    under the hood. We'll never have to worry about it!

    > Option `a` will still work, but `v-model.number` does the same work for us
    > out of the box! Option `b` is a syntax error, and `d` might just hang your browser!!
  features:
    multiple_choice:
      choices:
        a: |
          methods: {
              sendNumber() {
                  saveNumber(parseInt(this.theNumber) + 2);
              },
          },
        b: |
          ```vue
          <input
              type="number"
              v-model.parseInt="theNumber"
              min="1"
          />
          ```
        c: |
          ```vue
          <input
              type="number"
              v-model.number="theNumber"
              min="1"
          />
          ```
        d: |
          ```vue
          <input
              type="number"
              v-model="theNumber"
              @input="$event.target.value=parseInt(theNumber)"
              min="1"
          />
          ```
      correct: c


extending_webpack_entry:
  question: |
    Suppose we have a Symfony project that uses Webpack Encore. We've just finished
    building a new Vue component, but we only want to render it on a specific page.
    And so, we've decided to create a new Webpack entry.

    Which of the following options is not something that we need to do to accomplish this?
  explanation: |
    The 3 steps to creating a new Webpack entry that renders a Vue component are:
    - The .vue file with the component itself
    - A Controller that renders a Twig template, which includes a JavaScript file that
      renders the app inside this template
    - An entry in `webpack.config.js` to build our application.

    And while passing variables into our Vue component through the template is *nice*,
    it's not always needed!
  features:
    multiple_choice:
      choices:
        a: |
          A new `.vue` file to hold the new, main component
        b: |
          A `javascripts` block in the Twig template that contains different configurations
          and values to be used by our Vue App
        c: |
          A Controller, a Twig template and JavaScript file that will be loaded by the browser
          to instantiate the main component.
        d: |
          An `addEntry` call in `webpack.config.js` to tell webpack that it should build the file.
          a new entry.
      correct: b

extending_webpack_entry_2:
  question: |
    Which of these JavaScript file examples will succeed in rendering a Vue component
    in `Vue 2` inside an element with id `app`?
  explanation: |
    This bit of JavaScript code can be quite tricky to remember (and
    it does change slightly in Vue 3)!

    Thankfully we have the Vue documentation site to refresh our memory if any of these
    nuances get lost in forgotten-land!

    > In Vue 3, the code changes to:
    >
    > ```vue
    > import { createApp } from 'vue';
    > import App from '@/pages/my-page.vue';
    >
    > createApp(App).mount('#app');
    > ```
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          });
          ```
        b: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$mount('#app');
          ```
        c: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$render('#app');
          ```
        d: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          }).$mount('#app');
          ```
      correct: d

extending_mixin_basics:
  question: |
    Which of the following is *not* true about mixins?
  explanation: |
    Mixins are a *great* way to share logical functionality between
    components! They do not, however, have the ability to extend markup or
    styles. For that, just use regular components!
  features:
    multiple_choice:
      choices:
        a: |
          Mixins can help you share information between components, such as
          data attributes and even props!
        b: |
          Mixins can be useful for sharing methods and computed properties
          between components. Its properties and methods will be automatically
          available to other methods and even the template of the component
          you share it with!
        c: |
          Mixins are a great way to extend the template or styles in a component.
          The mixin template will be added to the component's template at the bottom, and styles
          will be automatically applied to any elements you provide styles for!
        d: |
          Mixins can help you with lifecycle behavior. By adding lifecycle functions
          to a mixin, those will be executed before any of your own component's
          lifecycle functions without replacing them! Sweet!
      correct: c

extending_more_mixin:
  question: |
    Take a look at these two components. Then choose which option below correctly shows
    a mixin that will allow them to remove their duplicated logic.

    ```vue
    <template>
        <h1>{{ pizzaName }}</h1>
        <p>{{ pizza.description }}</p>
        <ul>
            <li
                v-for="ingredient in pizza.ingredientes"
                :key="ingredient['@id']"
            >
                {{ ingredient.name }}
            </li>
        </ul>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaName() {
                return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```

    ```vue
    <template>
        <table v-if="pizza !== null">
            <tr>
                <td>{{ pizzaDescription }}</td>
                <td>{{ pizza.price }} </td>
            </tr>
        </table>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaDescription() {
                return this.pizza.name +  ' ' + pizza.description;
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```
  explanation: |
    The only data that is really shared between the components is the `pizza` data
    object and the `created` function. Everything else is unique to each component
    and so extracting it to a mixin does *not* make the most sense.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              }
          };
          ```
        b: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
        c: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
              },
          };
          ```
        d: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
      correct: a

extending_more_mixin_2:
  question: |
    Say I have this very simple counter component:

    ```vue
    <template>
        <div v-text="count" />
    </template>

    <script>
    export default {
        name: 'CounterComponent',
        data() {
            return {
                count: 0,
            };
        },
    };
    </script>
    ```

    Why is it important that data is a *function* that returns an object?
    Why can't data be set directly to the `{ count: 0 }` object?
  explanation: |
    As mentioned in Vue documentation, the reason why Vue needs
    data to be a function os so that each instance of the component can
    maintain a different copy of this data.

    This doesn't happen with `props` however, where we define each prop inside the
    `props` object, but we don't make it a function! The reason `props` doesn't
    need to be inside a function is because they don't really hold data. Its
    data is either passed down by other components on initialization, or defined
    by our `default` keyword.
  features:
    multiple_choice:
      choices:
        a: |
          Because the function needs to be called multiple times so that multiple
          instances of the component can have their own copy of the data.
        b: |
          Because it's the syntax defined by the Vue developers when designing the
          Options API.
        c: |
          It's not important but it gives us more versatility with regards to what can
          be computed in that initial `data` object.
        d: |
          Because this way, Vue can get every property of such returned object and
          add them as reactive properties to the instance's `this` keyword.
      correct: a

extending_cart_computed_prop:
  question: |
    In Vue, why is it important to avoid having the same information set as
    `data` onto 2 different components?
  explanation: |
    Avoid duplicated data whenever possible. It helps keep your application
    simple and avoid bugs!
  features:
    multiple_choice:
      choices:
        a: |
          Because with duplicated data, our memory footprint is bigger
          than we need.
        b: |
          Because when we have duplicated data, one copy of this data can
          change, while the other remains outdated. This forces us to
          complicate things and add hooks to keep both sides of the data
          up to date.
        c: |
          Because duplicated data is a bad programming technique that should
          be avoided if possible.
        d: |
          Because Vue reactivity has shortcomings when it needs to update a source
          of data that is present twice in your application.
      correct: b

extending_cart_computed_prop_2:
  question: |
    In the video, we showed this computed property, which merges the data
    returned by our watcher with the data that is present in the cart:

    ```javascript
    completeCart() {
        if (!this.cart || !this.products) {
            return null;
        }

        const completeItems = this.cart.items.map((cartItem) => (
            {
                product: this.products.find((product) => product['@id'] === cartItem.product),
                color: cartItem.color,
                quantity: cartItem.quantity,
            }
        ));

        return {
            items: completeItems,
        };
    },
    ```

    Take a closer look at the beginning of this function:

    ```javascript
    if (!this.cart || !this.products) {
        return null;
    }
    ```

    Why are we adding this check here? And what would happen if we didn't have it in place?
  explanation: |
    Indeed, our template *will* work without that check in place... but not before
    the computed function triggers some errors. This could still be ok... but nobody likes
    errors!
  features:
    multiple_choice:
      choices:
        a: |
          Without that check in place, our application won't load. We would see a
          blank page and an error in the console
        b: |
          This check is redundant. It is nice to have it, but our application can
          work just the same without it.
        c: |
          Without that check in place, our application will have errors in
          the console and our template will load, but with some bugs regarding
          reactivity. Data might change in the future that won't be reflected in
          our app.
        d: |
          Without this check, our template won't load until both variables get populated.
          We will have errors in the console, but once the data is loaded, the
          template would render successfully.
      correct: d

extending_parallel_ajax:
  question: |
    What is the advantage of using `await Promise.all()` for fetching more than one
    ajax call in an async function?
  explanation: |
    In the right situation, parallelizing ajax calls can save the user precious
    seconds when the internet connection is not optimal!

    > In our video, we end up taking a different route than `await Promise.all()`
    > just because there are multiple `async created` functions that get called. So
    > the end result is the same: Both calls get executed at almost the same time!
  features:
    multiple_choice:
      choices:
        a: |
          There is no advantage in doing so. `Promise.all()` is just syntax sugar.
          It will make our code more readable and clean.
        b: |
          `Promise.all()` has the ability to launch both ajax calls in parallel.
          Once all calls are completed, the code will continue as normal.
        c: |
          `Promise.all()` lets you organize your ajax calls in a way so that one call
          executes right after the other. This way, your data from the previous call
          is already available by the time you call the next one, which can be useful!
        d: |
          While `Promise.all()` won't give you any significant advantage, it's in general
          a little bit faster than the `async` keyword.
          for reasons of micro-optimizations.
      correct: b

extending_v_for_key:
  question: |
    In this video, we start with a component that iterates through a list of
    items using the items' `index` in the Array as `key`, like so:

    ```vue
    <shopping-cart-item
        v-for="(item, index) in items"
        :key="index"
        :item="item"
    />
    ```

    But this is not ideal! In a real application, each item should have an
    id that is unique to that item for the `key` attribute. But why is this so?
  explanation: |
    Vue uses the `key` attribute to identify unique items in a `v-for` list so that
    it can *only* modify the ones that really change. If the `key` for an item suddenly
    changes, Vue may re-create that component from scratch, causing optimization issues
    and potential data de-syncs.
  features:
    multiple_choice:
      choices:
        a: |
          The `key` becomes the internal id of the object, which is useful because
          it's included when Vue displays an error.
        b: |
          Because if we remove and add items from this list dynamically, the `key`
          for an existing item might change. That could cause Vue to destroy and
          re-create the entire component from scratch instead of reusing the existing
          instance.
        c: |
          Becauase Vue needs proper item ids to be assigned to its DOM nodes. In the
          case of `v-for` where each node comes from `data`, vue is asking for us
          to provide this internal id for them.
        d: |
          No reason, we really can put anything in the `key` attribute as long
          as it's not duplicated. Vue will work its magic under the hood so that
          items get rendered correctly
      correct: b

extending_prop_trap:
  question: |
    Imagine you have this component that renders the name of a Pizza object,
    which you can in turn modify by typing text into an input element:

    ```vue
    <template>
        <label>Name:</table>
        <pizza-name-input :pizza="pizza" />
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import PizzaNameInput from '@/components/pizza-name-input';

    export default {
        name: 'PizzaFormField',
        components: {
            PizzaNameInput,
        },
        data() {
            pizza: null,
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member'];
        },
    };
    </script>
    ```

    ```vue
    <template>
        <input type="text" v-model="pizza.name" />
    </template>

    <script>
    export default {
        name: 'PizzaNameInput',
        props: {
            pizza: {
                type: Object,
                required: true,
            },
        },
    };
    </script>
    ```

    What is the mistake we've just made here?
  explanation: |
    Our code will *still* work in this situation. But we can face weird side
    efefcts when changing either the `prop` or the original `data` object that
    contains the `pizza` object. Props were not designed to be modifiable by
    the component that receives them!
  features:
    multiple_choice:
      choices:
        a: |
          The `v-model` directive only works with `data` properties since `props`
          are read only.
        b: |
          We should be using `v-model.trim` here to get rid of extra white spaces.
          Failing to do this sanitation will end up with our backend database
          getting filled with garbage.
        c: |
          This code will work as it is, but by assigning a prop to a `v-model` directive,
          we're modifying that prop inside our child component. This is in general a bad idea
          and can lead to desync issues. Props were not designed to be modifiable.
        d: |
          Ha! Trick question! There is nothing wrong with this code.
          fine.
      correct: c

extending_emit_update_quantity:
  question: |
    Imagine we have a component that takes a value from the user and emits an
    event when the user changes it:

    ```vue
    <template>
        <input
            :value="pizza.name"
            @input="updatePizzaName"
        />
    </template>

    <script>
    export default {
        name: 'PizzaNameInput',
        props: {
            pizza: {
                type: Object,
                required: true,
            },
        },
        methods: {
            updatePizzaName($event) {
                this.$emit('update-pizza-name', { name: $event.target.value });
            },
        },
    };
    </script>
    ```

    From its parent component, I want to re-emit this event so that I can handle
    it further up the component tree!

    What is the best way of doing this?
  explanation: |
    While most of these options will work (except `d`), the best and simplest way to
    "bubble" an event up is by just using the template function shortcut `$emit` with
    its parameter `$event`!

    > Notice that when bubbling events up, best practices are to keep the event's name
    > the same. This is like when DOM events bubble up, they keep their name and their
    > data intact!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <pizza-name-input @update-pizza-name="$emit('update-pizza-name', $event)" />
          ```
        b: |
          ```vue
          <template>
              <pizza-name-input @update-pizza-name="updatePizzaNameParent" />
          </template>

          <script>
          export default {
              name: 'ParentComponent',
              methods: {
                  updatePizzaNameParent($event) {
                      this.emit('update-pizza-name', $event);
                  },
              },
          };
          </script>
          ```
        c: |
          ```vue
          <pizza-name-input @update-pizza-name="$emit('update-pizza-name-parent', $event)" />
          ```
        d: |
          ```vue
          <pizza-name-input @update-pizza-name="function() { $emit('update-pizza-name', $event); }" />
          ```
      correct: a

extend_add_to_cart_component:
  question: |
    In my pizza app, I have a section of the `show-pizza` component that allows
    the user to order some individual slices!

    Here's how the component looks:

    ```vue
    <template>
        <div
            :class="$style.component"
            v-if="pizza !== null"
        >
            <h1>{{ pizza.name }}</h1>

            <p>{{ pizza.description }}</p>

            <div class="order-buttons">
                <button
                    @click="orderSlices(1)"
                    :disabled="ordering"
                >
                    Order 1 slice!
                </button>

                <button
                    @click="orderSlices(2)"
                    :disabled="ordering"
                >
                    This pizza looks great! Order 2 slices!!
                </button>

                <button
                    @click="orderSlices(4)"
                    :disabled="ordering"
                >
                    I'm starving!! Order 4 slices!!!
                </button>
            </div>
        </div>
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import { orderPizza } from '@/services/order-pizza';

    export default {
        name: 'ShowPizza',
        data() {
            return {
                pizza: null,
                ordering: false,
            };
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member];
        },
        methods: {
            async orderPizza(slices) {
                await orderPizza(slices);
                this.ordered = true;
            },
        },
    };
    </script>

    <style lang="scss" module>
    .component :global {
        overflow: hidden;

        .order-buttons {
            padding-top: 20px;
            margin-top: 20px;
            border-top: 1px solid #FF0000;
        }
    }
    </style>
    ```

    But hey! Pizza headquarters are now asking me to include these ordering buttons EVERYWHERE
    in the app. They had such a good reception!

    I need to extract all the "ordering" logic into a separate component. What would this component
    look like?
  explanation: |
    Extracing functionality and presentation into a component can be tricky! This usually involves
    copying `data`, `props`, `methods`, `computed` properties and even lifecycle functions, apart
    from the obvious template and styles! Make sure you don't forget anything!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      pizza: null,
                      ordering: false,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
              methods: {
                  async orderSlices(slices) {
                      this.ordering = true;
                      await orderPizza(slices);
                      this.ordering = false;
                  },
              },
          };
          </script>

          <style lang="scss" module>
          .component {
              padding-top: 20px;
              margin-top: 20px;
              border-top: 1px solid #FF0000;
          }
          </style>
          ```
        b: |
          ```vue
          <template>
              <div :class="$style.component">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      ordering: false,
                  };
              },
              methods: {
                  async orderSlices(slices) {
                      this.ordering = true;
                      await orderPizza(slices);
                      this.ordering = false;
                  },
              },
          };
          </script>

          <style lang="scss" module>
          .component {
              padding-top: 20px;
              margin-top: 20px;
              border-top: 1px solid #FF0000;
          }
          </style>
          ```
        c: |
          ```vue
          <template>
              <div class="order-buttons">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      ordering: false,
                  };
              },
              methods: {
                  async orderSlices(slices) {
                      this.ordering = true;
                      await orderPizza(slices);
                      this.ordering = false;
                  },
              },
          };
          </script>
          ```
        d: |
          ```vue
          <template>
              <div class="order-buttons">
                  <button
                      @click="orderSlices(1)"
                      :disabled="ordering"
                  >
                      Order 1 slice!
                  </button>

                  <button
                      @click="orderSlices(2)"
                      :disabled="ordering"
                  >
                      This pizza looks great! Order 2 slices!!
                  </button>

                  <button
                      @click="orderSlices(4)"
                      :disabled="ordering"
                  >
                      I'm starving!! Order 4 slices!!!
                  </button>
              </div>
          </template>

          <script>
          import { orderPizza } from '@/services/order-pizza';

          export default {
              name: 'OrderButtons',
              data() {
                  return {
                      ordering: false,
                  };
              },
          };
          </script>

          <style lang="scss" module>
          .component {
              padding-top: 20px;
              margin-top: 20px;
              border-top: 1px solid #FF0000;
          }
          </style>
          ```
      correct: b

extending_cart_controls_component2:
  question: |
    Here's the same component from the last challenge:

    ```vue
    <template>
        <div
            :class="$style.component"
            v-if="pizza !== null"
        >
            <h1>{{ pizza.name }}</h1>

            <p>{{ pizza.description }}</p>

            <div class="order-buttons">
                <button
                    @click="orderSlices(1)"
                    :disabled="ordering"
                >
                    Order 1 slice!
                </button>

                <button
                    @click="orderSlices(2)"
                    :disabled="ordering"
                >
                    This pizza looks great! Order 2 slices!!
                </button>

                <button
                    @click="orderSlices(4)"
                    :disabled="ordering"
                >
                    I'm starving!! Order 4 slices!!!
                </button>
            </div>
        </div>
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import { orderPizza } from '@/services/order-pizza';

    export default {
        name: 'ShowPizza',
        data() {
            return {
                pizza: null,
                ordering: false,
            };
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member];
        },
        methods: {
            async orderPizza(slices) {
                this.ordering = true;
                await orderPizza(slices);
                this.ordering = false;
            },
        },
    };
    </script>

    <style lang="scss" module>
    .component :global {
        overflow: hidden;

        .order-buttons {
            padding-top: 20px;
            margin-top: 20px;
            border-top: 1px solid #FF0000;
        }
    }
    </style>
    ```

    We've just moved its order buttons logic into an outside component called `order-buttons`!
    After including the `order-buttons` component, how would this component look like?
  explanation: |
    As important as being accurate when extracting logic to an external component is
    to *remove* the left overs so that you don't end up with repeated `data` or `props`!
  features:
    multiple_choice:
      choices:
        a: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import { orderPizza } from '@/services/order-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;
          }
          </style>
          ```
        b: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
                  ordered: false,
                  ordering: false,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;
          }
          </style>
          ```
        c: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;
          }
          </style>
          ```
        d: |
          ```vue
          <template>
              <div
                  :class="$style.component"
                  v-if="pizza !== null"
              >
                  <h1>{{ pizza.name }}</h1>

                  <p>{{ pizza.description }}</p>

                  <order-buttons />
              </div>
          </template>

          <script>
          import { getPizza } from '@/services/get-pizza';
          import OrderButtons from '@/components/order-buttons';

          export default {
              name: 'ShowPizza',
              components: {
                  OrderButtons,
              },
              data() {
                  return {
                      pizza: null,
                  };
              },
              async created() {
                  this.pizza = (await getPizza()).data['hydra:member];
              },
          };
          </script>

          <style lang="scss" module>
          .component :global {
              overflow: hidden;

              .order-buttons {
                  padding-top: 20px;
                  margin-top: 20px;
                  border-top: 1px solid #FF0000;
              }
          }
          </style>
          ```
      correct: c

extending_smart_watcher:
  question: |
    What are deep watchers useful for?
  explanation: |
    In complex objects where you need to execute watchers over multiple
    nested properties, deep watchers are the answer. The reason this is
    not Vue's default behavior is that deep watchers are harder to
    process!
  features:
    multiple_choice:
      choices:
        a: |
          Deep watchers are used for large objects or arrays where
          we need a more optimized and faster method for watching
          property changes
        b: |
          Deep watchers are used when the watched object is not a
          simple data type (i.e. `Number`, `String` or `Boolean`)
        c: |
          Deep watchers are used when you need to watch changes in
          complex objects, where nested properties might change.
      correct: c

extending_smart_watcher_2:
  question: |
    In this component, I'm using a watcher to check changes in
    the pizza object in my component's `data`. But some of the
    changes are not triggering a watch!!

    ```vue
    <template>
        // Some fancy template here!
    </template>

    <script>
    import { getPizza } from '@/services/get-pizza';
    import { executeFancyWatcherLogicHere } from '@/some/crazy/path';

    export default {
        name: 'PizzaComponent',
        data() {
            return {
                pizza: null;
            };
        },
        async created() {
            this.pizza = (await getPizza()).data['hydra:member'];
        },
        watch: {
            async pizza() {
                await executeFancyWatcherLogicHere();
            },
        },
    };
    </script>
    ```

    I'm thinking that since pizza is a complex object, once it loads,
    I need to switch the watcher to be a deep watcher. What is the
    correct way to do it?
  explanation: |
    Remember that watchers have 2 syntaxes: They can be a function,
    with the name of the property to watch, or they can be an object
    with options!

    > There are more options to watchers than what we've seen here!
    > You can refer to Vue's documentation to see what those are.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          watch: {
              pizza: {
                  deep: true,
                  handler() {
                      executeFancyWatcherLogicHere();
                  },
              },
          },
          ```
        b: |
          ```javascript
          watch: {
              pizza() {
                  this.setDeep = true;
                  executeFancyWatcherLogicHere();
              },
          },
          ```
        c: |
          ```javascript
          watch: {
              pizza: {
                  deep: true,
                  watcher() {
                      executeFancyWatcherLogicHere();
                  },
              },
          },
          ```
        d: |
          ```javascript
          watch: {
              pizza: {
                  deepWatcher() {
                      executeFancyWatcherLogicHere();
                  },
              },
          },
          ```
      correct: a
