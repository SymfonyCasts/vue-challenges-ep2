# This lies in a different file so as to avoid terrible conflicts when trying to merge.
# So once this is approved, I'll just copy-paste into `challenges.yml` and *then* merge.

extending_extra_dom_updates:
  question: |
    As was mentioned in the video, we could have a better way of telling the user that
    he needs to choose a color, ther than a simple alert.

    Which of these solutions would be the best one?

extending_webpack_entry:
  question: |
    In a Symfony project that uses Webpack Encore, which of these options is *not*
    required to create a new entry where a totally new Vue App will be rendered?
  explanation: |
    Correct! Our way of passing data to Vue through the template is absolutely *not*
    needed by any Vue App. We choose to do so because it's simple and super fast!
  features:
    multiple_choice:
      choices:
        a: |
          A new `.vue` file to hold the new, main component
        b: |
          A JavaScript block in the Twig template that contains different configurations
          and values to be used by our Vue App
        c: |
          A Controller, a Twig template and JavaScript file that will be loaded by the browser
          to instantiate the main component.
        d: |
          An `addEntry` call in `webpack.config.js` to tell webpack that it should build the file.
          a new entry.
    correct: b

extending_webpack_entry_2:
  question: |
    Which of these JavaScript file examples will succeed in rendering a Vue component
    inside an element with id `#app`?
  explanation: |
    That's right! This bit of JavaScript code can be quite tricky to remember (and
    it does change slightly in Vue 3)!

    Thankfully we have the Vue documentation site to refresh our memory if any of these
    nuances get lost in forgotten-land!
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          });
          ```
        b: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$mount('#app');
          ```
        c: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: App,
          }).$render('#app');
          ```
        d: |
          ```javascript
          import Vue from 'vue';
          import App from '@/pages/my-page.vue';

          new Vue({
              render: (h) => h(App),
          }).$mount('#app');
          ```
     correct: d

extending_mixin_basics:
  question: |
    What are mixins *not* good for?
  explanation: |
    Correct! Mixins are a *great* way to share logical functionality between
    components! They do not, however, have the ability to extend markup or
    styles. For that, just use regular Components!
  features:
    multiple_choice:
      choices:
        a: |
          Mixins can help you share information between components, such as
          data attributes and even props!
        b: |
          Mixins can be usefull for sharing methods and computed properties
          between components. Its items will be automatically availble to other
          methods and even the template of the component you share it with!
        c: |
          Mixinns are a great way to extend the template or styles in a component.
          Such will be added to the component's template at the bottom, and styles
          will be automatically applied to any elements you provide styles for!
        d: |
          Mixins help you with life-cycle behavior, adding life cycle functions
          to a mixin will have those executed before any of your own component's
          life cycle functions without replacing them! Sweet!
      correct: c

extending_more_mixin:
  question: |
    Take a look at these two components and choose the answer that provides
    the right mixin, so that the components don't have to duplicate its
    shared logic!

    ```vue
    <template>
        <h1>{{ pizzaName }}</h1>
        <p>{{ pizza.description }}</p>
        <ul>
            <li
                v-for="ingredient in pizza.ingredientes"
                :key="ingredient['@id']"
            >
                {{ ingredient.name }}
            </li>
        </ul>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaName() {
                return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```

    ```vue
    <template>
        <tr>
            <td>{{ pizzaDescription }}</td>
            <td>{{ pizza.price }} </td>
        </tr>
    </template>

    <script>
    import { getPizza } from '@/services/pizza';

    export default {
        name: 'PizzaDetails',
        data() {
            return {
                pizza: null,
            };
        },
        computed: {
            pizzaDEscription() {
                return this.pizza.name +  ' ' + pizza.description;
            },
        },
        async created: {
            this.pizza = (await getPizza()).data;
        },
    };
    </script>
    ```
  explanation: |
    That's right! The only data that is really shared between components is the `pizza` data
    object and the component's `created` function. Everything else is unique to each component
    and so extracting it to a mixin does *not* make the most sense.
  features:
    multiple_choice:
      choices:
        a: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  pizza: null,
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              }
          };
          ```
        b: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  pizza: null,
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaDEscription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
        c: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  pizza: null,
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
              },
          };
          ```
        d: |
          ```javascript
          import { getPizza } from '@/services/pizza';

          export default {
              data() {
                  pizza: null,
              },
              async created() {
                 this.pizza = (await getPizza()).data;
              },
              computed: {
                  pizzaName() {
                      return this.pizza.name + (this.pizza.hasPineapple ? ' w/ Pineapple' : '');
                  },
                  pizzaDescription() {
                      return this.pizza.name +  ' ' + pizza.description;
                  },
              },
          };
          ```
      correct: a

extending_more_mixin_2:
  question: |
    Say I have this very simple counter component:

    ```vue
    <template>
        <div v-text="count" />
    </template>

    <script>
    export default {
        name: 'CounterComponent',
        data() {
            return {
                count: 0,
            };
        },
    };
    </script>
    ```

    Why is it important to have data being a function that returns an object?
  explanation: |
    Correct! As we've been able to see in the video, to have reactive components that are
    assigned to the Vue's `this` root object, we need to make `data` be a function.

    This doesn't happen with `props` however, where we define each prop inside the
    `props` object, but we don't make it a function!
  features:
    multiple_choice:
      choices:
        a: |
          Because the function needs to be called multiple times for multiple instances
          of the component.
        b: |
          Because it's the syntax defined by the Vue developers when designing the
          Options API.
        c: |
          It's not important but it gives us more versatility with regards to what can
          be computed in that initial `data` object.
        d: |
          Because this way, Vue can get every property of such returned object and
          add them as reactive properties to the instance's `this` keyword.
      correct: d
